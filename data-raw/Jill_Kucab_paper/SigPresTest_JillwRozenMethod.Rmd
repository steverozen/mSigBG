---
title: "Jill's data: Our method VS Jill's method"
author: "Xinyi"
date: "2023-02-28"
output: html_document
---
Description: This file is trying to explore how to decide whether a target signature extracted by rozen method is different from that of the background. 
The above aim is explored in the following ways:
1. Are there signatures that Rozen Method picks up but Jill did not? (Hard problem, must defined what is an significant signature that differs from the bg in Rozen method)
2. How to we decide whether one of the control sample does not have signature after Rozen method (What should be taken into account? mutation counts & signature cosine similarity?)
3. Why would the signature presence test has such low p-value for the controls in Jill's data?

# Load packages
```{r}
library(ICAMS)
library(mSigAct)
library(philentropy)
library(factoextra)
library(gplots)
library(nloptr)
 library(parallel)
devtools::load_all(".")

# if (!requireNamespace("mSigAct", quietly = TRUE) ||
#   packageVersion("mSigAct") < "2.3.6") {
#   remotes::install_github(repo = "steverozen/mSigAct", ref = "v2.3.6-branch")
# }
```


# Functions for this File 
```{r}
pcat <- function(catalog) {
  par(pin = c(3*ncol(catalog), 1))
  par(mfrow = c(ncol(catalog), 1))
  par(mar = c(2, 4, 4, 2))
  par(cex = 0.8)
  par(cex.main = 1.4) 
  xlabels <- FALSE
  for (i in 1:ncol(catalog)) {
    if (FALSE && i == ncol(catalog)) { # FALSE an experiment
      xlabels <- TRUE
      par(mar = c(4.5, 4, 3, 2))
    }
    
    ICAMS::PlotCatalog(catalog[ , i, drop = FALSE],
                       upper = (i == 1),
                       xlabels = xlabels)
  }
}
```

```{r}
one.separation <- function(sig.name, spectra, bg.sig.info, my.seed = 101010) {
  
  set.seed(my.seed, kind = "L'Ecuyer-CMRG")
  
  if (is.null(attr(spectra, "abundance"))) {
    stop("NULL abundance for ", sig.name)
  }
  
  ret <- SeparateSignatureAndSpectra(
    spectra          = spectra,
    bg.sig.info      = bg.sig.info,
    m.opts           = NULL,
    # start.b.fraction = 0.5,
    # 0.1 - 0.49 is ok & 0.6 
    # 0.499 starts the hanging problem
    start.b.fraction = 0,
    sig.name         = sig.name
  )
  
  return(ret)
}
```

```{r}
sep_comp_bg <- function(compound.name, subs.all, MSM_table, jill.bg){
  
  compound.spectra <-matrix(data=NA,nrow=96)
  compound.key <- paste0(compound.name,"_")
  compound.samples <- unique(subs.all[grep(compound.key, subs.all[,3]),"Sample" ,])
  sig.name <- MSM_table[MSM_table$Sample.Name == compound.name,2]
  
  
  for (compound.subtype in compound.samples){
    if(is.na(compound.spectra[1]))
      compound.spectra <- Jill_to_SBS96(subs.all[grep(compound.subtype, subs.all[,3]), ,drop = FALSE])
    else
      compound.spectra <- cbind(compound.spectra,
                                Jill_to_SBS96(subs.all[grep(compound.subtype, subs.all[,3]), ,drop = FALSE]))
  }
  colnames(compound.spectra)<-compound.samples
  
  compound.sep <- one.separation(compound.name, compound.spectra, jill.bg)
  
  return(compound.sep)
}

```

```{r}
sig_pres_test <- function(compound.name, MSM_table, subs.all){
  compound.spectra <-matrix(data=NA,nrow=96)
  compound.key <- paste0(compound.name,"_")
  compound.samples <- unique(subs.all[grep(compound.key, subs.all[,3]),"Sample" ,])
  sig.name <- MSM_table[MSM_table$Sample.Name == compound.name,2]
  
  for (compound.subtype in compound.samples){
    # print(compound.subtype)
    if(is.na(compound.spectra[1]))
      compound.spectra <- Jill_to_SBS96(subs.all[grep(compound.subtype, subs.all[,3]), ,drop = FALSE])
    else
      compound.spectra <- cbind(compound.spectra,
                                Jill_to_SBS96(subs.all[grep(compound.subtype, subs.all[,3]), ,drop = FALSE]))
  }
  colnames(compound.spectra)<-compound.samples
  
  seps <- sep_comp_bg(compound.name ,subs.all, MSM_table, jill.bg)
  two.sigs <- cbind(seps$inferred.target.sig.as.catalog, 
                    jill.bg$background.sig)
  
  m.opts <- mSigAct::DefaultManyOpts()
  # my_opts <- mSigAct::DefaultManyOpts(likelihood.dist = "neg.binom")
  # my_opts$nbinom.size <- 1
  
  retval <- mSigAct::SignaturePresenceTest(
    spectra          = compound.spectra,
    sigs             = two.sigs,
    target.sig.index = 1,
    # eval_f           = mSigAct::ObjFnBinomMaxLHNoRoundOK,
    m.opts           = m.opts)
  
  #View(retval)
  ret <- lapply(retval, function(x) x$chisq.p)
  names(ret) <- paste(names(ret), sig.name, sep = "_")
  
  return(ret)
}
```

```{r}
sig_pres_test_paa <- function(compound.name, MSM_table, subs.all){
  compound.spectra <-matrix(data=NA,nrow=96)
  compound.key <- paste0(compound.name,"_")
  compound.samples <- unique(subs.all[grep(compound.key, subs.all[,3]),"Sample" ,])
  sig.name <- MSM_table[MSM_table$Sample.Name == compound.name,2]
  
  for (compound.subtype in compound.samples){
    # print(compound.subtype)
    if(is.na(compound.spectra[1]))
      compound.spectra <- Jill_to_SBS96(subs.all[grep(compound.subtype, subs.all[,3]), ,drop = FALSE])
    else
      compound.spectra <- cbind(compound.spectra,
                                Jill_to_SBS96(subs.all[grep(compound.subtype, subs.all[,3]), ,drop = FALSE]))
  }
  colnames(compound.spectra)<-compound.samples
  
  seps <- sep_comp_bg(compound.name ,subs.all, MSM_table, jill.bg)
  two.sigs <- cbind(seps$inferred.target.sig.as.catalog, 
                    jill.bg$background.sig)

  ####################################  
  my_opts <- mSigAct::DefaultManyOpts(likelihood.dist = "neg.binom")
  my_opts$nbinom.size <- 1
  my_opts$trace <- 1e10
  
  
  table <- matrix(data=NA, nrow=3, ncol=ncol(compound.spectra))
  rownames(table) <- c(colnames(two.sigs), "Total.Count")
  colnames(table) <- rep("temp", ncol(compound.spectra))
  
  for (i in 1:ncol(compound.spectra)){
    retval <-
      mSigAct::PresenceAssignActivity(
        spectra = compound.spectra,
        #spectra = compound.spectra[,i, drop=FALSE],
        sigs = two.sigs,
        output.dir = "/home/e0261891/project_folder/mSigBG/data-raw/Jill_Kucab_paper/output/paa",
        p.thresh = 1e-10 / (4 * ncol(two.sigs)),
        m.opts = my_opts,
        num.parallel.samples = 1,
        mc.cores.per.sample = 2,
        seed = 8312,
        use.forward.search = TRUE
      )
    
    res <- retval$proposed.assignment
    colnames(table)[i] <- colnames(res)[1]
    for (j in rownames(res)){
      table[j,colnames(res)] <- res[j,]
    }
    table["Total.Count",colnames(res)] <- sum(compound.spectra[,i])
    colnames(table)[i] <- colnames(res)
    
    #names(ret) <- paste(names(ret), sig.name, sep = "_")
  }
  
  return(table)
}
```


# Prepare the data needed
Read Input from Jill Kucab's data
```{r}
sig.all <- read.table("Jill_Mutagen53_sub_signature.txt",header = TRUE, sep ="\t")

subs.all <- read.table("Jill_denovo_subclone_subs_final.txt",header = TRUE, sep ="\t")
```

```{r}
# REMOVE X IN "X1.8.DNP..0.125.uM." for sig.name column names for MSM_table matching 
for (i in 1:length(colnames(sig.all))){
  if (substring(colnames(sig.all)[i], 1, 1) =="X")
    colnames(sig.all)[i] <- substring(colnames(sig.all)[i],2)
}
```

```{r}
# Creating a table to map MSM code to sig.name 
MSM_table <- read.table("MSM_table", header = TRUE, sep = "\t") #, col.names=c("Sample.Name", "Treatment") )
names <- gsub(" ", ".",MSM_table[,2])
names <- gsub("\\(", ".",names)
names <- gsub("\\)", ".",names)
names <- gsub("\\+", ".",names)
names <- gsub(",",".",names)
names <- gsub("-",".",names)
MSM_table[,2] <- names
```

```{r}
# MSM0.11	Temozolomide..200.uM.			
# MSM0.75	Temozolomide..200.uM.
# in the MSM table provided, two MSM codes are mapped to the same signature name
# in Signature names, one is named as Temozolomide..200.uM..1
# Here we assume that MSM0.75 is named as Temozolomide..200.uM..1
MSM_table[MSM_table[1]=="MSM0.75",2] <- "Temozolomide..200.uM..1"
```

```{r}
# separate the samples in subs.all

if (!file.exists("jill.all.spectra.Rdata")){
  by.sample <- split(subs.all, subs.all$Sample.Name) # output a list grouped by Sample.Name
  all.spectra <- lapply(by.sample, Jill_to_SBS96)
  save(all.spectra, file = "jill.all.spectra.Rdata")
}else{
  load("jill.all.spectra.Rdata")
}

  
alls <- do.call(cbind, all.spectra)
rownames(MSM_table) <- MSM_table$Sample.Name
colnames(alls) <- paste(colnames(alls), MSM_table[colnames(alls), "Treatment"])
ICAMS::PlotCatalogToPdf(alls, "jill.all.pdf")

ICAMS::PlotCatalogToPdf(alls[ , grepl("Control", colnames(alls), fixed = TRUE)], "jill.control.pdf")

jill_ctrl_spectra <- alls[ , grepl("Control", colnames(alls), fixed = TRUE)]
```

```{r}
all.names <- unique(subs.all["Sample.Name"])
ctrl.names <- c("MSM0.118","MSM0.119","MSM0.131","MSM0.4",
                "MSM0.86","MSM0.9","MSM0.1","MSM0.45","MSM0.8",
                "MSM0.128","MSM0.129","MSM0.120","MSM0.127",
                "MSM0.6","MSM0.37")
```

# Generate BG info 
```{r}
jill.bg <- MakeBackgroundInfo(jill_ctrl_spectra)
```

```{r, fig.height=1.5, fig.width=10}
pcat(jill.bg$background.sig)
```
## Exploring Signature Presence 
### scripting for all samples 
```{r}
ctrl.msm <- MSM_table[grep("Control", MSM_table[,2]),1]  
i <- ctrl.msm[15]
ctrl.i <- c()
for (i in ctrl.msm[1:10]){
  ctrl.i <- c(ctrl.i,all.names[all.names[1] == i])
}
ctrl.i
```

```{r}
ctrl.sig.pres.test <- mclapply(ctrl.i, function(x){sig_pres_test(x, MSM_table, subs.all)}, mc.cores = 10L)
names(ctrl.sig.pres.test) <- ctrl.i
View(ctrl.sig.pres.test)
```


```{r}
ctrl.sig.pres.test.paa <- mclapply(ctrl.i, function(x){sig_pres_test_paa(x, MSM_table, subs.all)}, mc.cores = 10L)
names(ctrl.sig.pres.test.paa) <- ctrl.i
View(ctrl.sig.pres.test.paa)
save(ctrl.sig.pres.test.paa, file = "ctrl.sig.pres.test.paa.Rdata")
```

```{r}
for (i in names(ctrl.sig.pres.test.paa)) print(ctrl.sig.pres.test.paa[[i]])
```

```{r}
all.sig.pres.test.paa <- mclapply(all.names[,1], function(x){sig_pres_test_paa(x, MSM_table, subs.all)}, mc.cores = 100L)
names(all.sig.pres.test.paa) <- all.names[,1]
save(all.sig.pres.test.paa, file = "all.sig.pres.test.paa.Rdata")
```

```{r}
potential.sig <- NULL
for (i in all.names[,1]){
  if (!MSM_table[i,2] %in% colnames(sig.all)){
    if (!MSM_table[i,1] %in% ctrl.i)
      potential.sig <- c(potential.sig, i)
  }
}
```

```{r}
for (i in potential.sig){
  print(MSM_table[i,2])
  print(all.sig.pres.test.paa[[i]])
}
```
```{r}
for (i in all.compound.sep){
  if (setequal(all.compound.sep[[1]]$inferred.target.sig.as.catalog, target_sig))
    print(i)
}
```


### For one sample
Signature presence test
Problem: signature presence test test for whether the spectra can be reconstructed without the target signature 
BUT for our case we need to consider the counts (i.e. if input spectra has similar pattern AND counts to background, the signature may not be legitimate)

#### Test diff between using all.spectra & subtype-based spectra
```{r}

compound.name <- "MSM0.118"

# compound.name <- compounds[2]  # "MSM0.47" "MMS..100.uM."
# compound.name <- compounds[99] # "MSM0.118" "DMSO.Control..0.5%....HS9"

print(compound.name)
compound.spectra <-matrix(data=NA,nrow=96)
compound.key <- paste0(compound.name,"_")
compound.samples <- unique(subs.all[grep(compound.key, subs.all[,3]),"Sample" ,])

sig.name <- MSM_table[MSM_table$Sample.Name == compound.name,2]

if(sig.name %in% colnames(sig.all)){
  print("It is identified as Signature by Jill")
}else{
  print("Jill says there's no signature!")
}

print(sig.name)
for (compound.subtype in compound.samples){
  # print(compound.subtype)
  if(is.na(compound.spectra[1]))
    compound.spectra <- Jill_to_SBS96(subs.all[grep(compound.subtype, subs.all[,3]), ,drop = FALSE])
  else
    compound.spectra <- cbind(compound.spectra,
                              Jill_to_SBS96(subs.all[grep(compound.subtype, subs.all[,3]), ,drop = FALSE]))
}
colnames(compound.spectra)<-compound.samples

system.time(compound.sep <- one.separation(compound.name, compound.spectra, jill.bg))
```


```{r}
two.sigs <- cbind(compound.sep$inferred.target.sig.as.catalog, 
                  jill.bg$background.sig)

m.opts <- mSigAct::DefaultManyOpts()
retval <- mSigAct::SignaturePresenceTest(
  spectra          = compound.spectra,
  sigs             = two.sigs,
  target.sig.index = 1,
  # eval_f           = mSigAct::ObjFnBinomMaxLHNoRoundOK,
  m.opts           = m.opts)

lapply(retval, function(x) x$chisq.p)
```

```{r}
lapply(retval, function(x) x$chisq.p)
```

```{r}
philentropy::cosine_dist(compound.sep$inferred.target.sig.as.catalog, 
                  jill.bg$background.sig, testNA = FALSE)
```
