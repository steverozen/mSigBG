---
author: "Steve Rozen"
output: html_document
date: '`r Sys.Date()`'
params:
  bgfactor: 2
  showrecon: TRUE
  showbgspec: TRUE
  onefhigh: 2.5
  verbose: TRUE
  count.nbinom.size: 20
  def.fig.wid: 4
  
title: Background subtraction for various platinum-based chemotherapeutics  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This is an example of background subtraction using the mSigBG package.

In this example we subtract the background signatures of
HepG2 and MCF-10A cells from the spectra of cells treated with
three platinum-based chemotherapies.

`r ifelse(params$verbose, "## Libraries, graphics parameters, and helper functions", "")`


```{r, libraries, echo=params$verbose}
library(mSigBG, quietly = TRUE)
library(ICAMS, quietly = TRUE)
library(BSgenome.Hsapiens.1000genomes.hs37d5, quietly = TRUE)
library(philentropy, quietly = TRUE)
```

```{r, util_func, echo=params$verbose}

set.initial.par <- function(catalog) {
  par(pin = c(3*ncol(catalog), 1))
  par(mfrow = c(ncol(catalog), 1))
  par(mar = c(2, 4, 4, 2))
  par(cex = 0.8)
  par(cex.main = 1.4) 
}

last.bottom.mar <- 4.5
```


```{r, define_pcat1, echo=params$verbose}
# Plot a single catalog
pcat1 <- function(catalog, ylim = NULL) {
  par(pin = c(5, 1))
  par(mar = c(5, 4, 5, 4))
  par(cex = 0.8)
  par(cex.main = 1.4)
  bp <- ICAMS::PlotCatalog(catalog[ , 1, drop = FALSE],
                           upper   = TRUE,
                           xlabels = TRUE,
                           ylim    = ylim
                           )
  return(invisible(bp$plot.object))
}
```

```{r, define_pcat, echo=params$verbose}
pcat <- function(catalog) {
  set.initial.par(catalog)
  xlabels <- FALSE
  for (i in 1:ncol(catalog)) {
    if (FALSE && i == ncol(catalog)) { # FALSE an experiment
      xlabels <- TRUE
      par(mar = c(last.bottom.mar, 4, 3, 2))
    }
    
    ICAMS::PlotCatalog(catalog[ , i, drop = FALSE],
                       upper = (i == 1),
                       xlabels = xlabels)
  }
}
```


## Generate and read input spectra

These are the spectra from cell lines exposed to cisplatin, carboplatin, or oxaliplatin

### Generate spectra "catalogs" from HepG2 and MCF-10A cisplatin VCF files

```{r, process.cisplatin.vcfs}
if (!file.exists("example.spectra/cis.spectra.Rdata")) {
  vcfs <- list.files("example.vcfs/HepG2_Cis/", full.names = TRUE)
  hepg2.cis <- ICAMS::StrelkaSBSVCFFilesToCatalog(
    files      = vcfs,
    ref.genome = BSgenome.Hsapiens.1000genomes.hs37d5,
    region     = "genome")$catSBS96
  colnames(hepg2.cis) <- 
    sub(".vcf", "", x = colnames(hepg2.cis), fixed = TRUE)
  
  vcfs <- list.files("example.vcfs/MCF10A_Cis/", full.names = TRUE)
  mcf10a.cis <- ICAMS::StrelkaSBSVCFFilesToCatalog(
    files      = vcfs,
    ref.genome = BSgenome.Hsapiens.1000genomes.hs37d5,
    region     = "genome")$catSBS96
  colnames(mcf10a.cis) <- 
    sub(".vcf", "", x = colnames(mcf10a.cis), fixed = TRUE)
  
  save(hepg2.cis, mcf10a.cis, file = "example.spectra/cis.spectra.Rdata")
  rm(vcfs)
} else {
  load("example.spectra/cis.spectra.Rdata")
}

```

### Read carboplatin and oxalipltin spectra catalogs

```{r, read.catalogs}
hepg2.car  <- ICAMS::ReadCatalog("example.spectra/HepG2_Car.csv", 
                                 ref.genome = BSgenome.Hsapiens.1000genomes.hs37d5,
                                 region = "genome",
                                 catalog.type = "counts")

hepg2.oxa  <- ICAMS::ReadCatalog("example.spectra/HepG2_Oxa.csv", 
                                 ref.genome = BSgenome.Hsapiens.1000genomes.hs37d5,
                                 region = "genome",
                                 catalog.type = "counts")
colnames(hepg2.oxa) <- sub("_SNVresult_intersect", "",
                           x = colnames(hepg2.oxa), fixed = TRUE)
colnames(hepg2.oxa) <- sub("pl_", "a_",
                           x = colnames(hepg2.oxa), fixed = TRUE)

mcf10a.car <- ICAMS::ReadCatalog("example.spectra/MCF10A_Car.csv", 
                                 ref.genome = BSgenome.Hsapiens.1000genomes.hs37d5,
                                 region = "genome",
                                 catalog.type = "counts")
colnames(mcf10a.car) <- sub("_SNVresult_intersect", "",
                           x = colnames(mcf10a.car), fixed = TRUE)
colnames(mcf10a.car) <- sub("_Carb_", "_car_",
                           x = colnames(mcf10a.car), fixed = TRUE)

```

### Input as count spectra

```{r, plot.input.hepg2.cis, fig.height=7, fig.width=7}
pcat(hepg2.cis)
```

```{r, plot.input.mcf10a.cis, fig.height=10, fig.width=7}
pcat(mcf10a.cis)
```

```{r, plot.input.hepg2.car, fig.height=5, fig.width=7}
pcat(hepg2.car)
```

```{r, plot.input.mcf10a.car, fig.height=7, fig.width=7}
pcat(mcf10a.car)
```

```{r, plot.input.oxa, fig.height=5, fig.width=7}
pcat(hepg2.oxa)
```


`r ifelse(params$verbose, "### Input as density spectra", "")`

```{r input_spectra_as_density, eval=FALSE, echo=params$verbose}
pcat(ICAMS::TransformCatalog(spectra, 
                             target.catalog.type = "density"))
```

## Decompose the background and target signatures

```{r, separate.hepg2}
one.separation <- function(sig.name, sig.list, bg.sig.info, my.seed = 101010) {
  
  set.seed(my.seed, kind = "L'Ecuyer-CMRG")
  
  spectra <- sig.list[[sig.name]]
  
  if (is.null(attr(spectra, "abundance"))) {
    stop("NULL abundance for ", sig.name)
  }
  
  ret <- SeparateSignatureAndSpectra(
    spectra          = spectra,
    bg.sig.info      = bg.sig.info,
    m.opts           = NULL,
    start.b.fraction = 0.5,
    sig.name         = sig.name
  )

  return(ret)
}

hepg2.exposures <- list(hepg2.cis, hepg2.car, hepg2.oxa)
names(hepg2.exposures) <- c("HepG2.cis.sig", "HepG2.car.sig", "HepG2.oxa.sig")
if (!file.exists("all.separated.Rdata")) {
  hepg2.separated <- lapply(X           = names(hepg2.exposures),
                            FUN         = one.separation,
                            sig.list    = hepg2.exposures,
                            bg.sig.info = background.info[["HepG2"]])
  names(hepg2.separated) <- names(hepg2.exposures)
}
```

```{r, separate.mcf10a}

mcf10a.exposures <- list(mcf10a.cis, mcf10a.car)
names(mcf10a.exposures) <- c("MCF10A.cis.sig", "MCF10.car.sig")
if (!file.exists("all.separated.Rdata")) {
  mcf10a.separated <- lapply(X           = names(mcf10a.exposures),
                             FUN         = one.separation,
                             sig.list    = mcf10a.exposures,
                             bg.sig.info = background.info[["MCF10A"]])
  names(mcf10a.separated) <- names(mcf10a.exposures)
  
  all.separated <- c(hepg2.separated, mcf10a.separated)
  save(all.separated, file = "all.separated.Rdata")
} else {
  load("all.separated.Rdata")
}

```

```{r, spectra.heatmap}
all.spectra <- do.call(cbind, c(hepg2.exposures, mcf10a.exposures))

cosine.sim <- philentropy::distance(t(all.spectra), method = "cosine")
rownames(cosine.sim) <- colnames(all.spectra)
colnames(cosine.sim) <- colnames(all.spectra)
gplots::heatmap.2(x = cosine.sim,
                  dendrogram = "column",
                  margins = c(9, 9),
                  cex.axis = 0.5,
                  symm = TRUE,
                  trace = "none")


```


```{r, spectra.heatmap2}
to.delete <- grep("Oxpl_cl4", colnames(all.spectra))
cosine.sim <- philentropy::distance(
  t(all.spectra[ , -to.delete]), method = "cosine")
rownames(cosine.sim) <- colnames(all.spectra)[-to.delete]
colnames(cosine.sim) <- colnames(all.spectra)[-to.delete]
gplots::heatmap.2(x = cosine.sim,
                  dendrogram = "column",
                  margins = c(9, 9),
                  cex.axis = 0.5,
                  symm = TRUE,
                  trace = "none")


```

## Signature based on inferred target spectra plus uncertainty

```{r, sig.and.uncertainty.counts, fig.height=3, fig.width=7}
par(mfrow = c(1, 1))
par(mar = c(7, 5, 7, 2))
par(cex = 0.8)
par(cex.main = 1.4) 
for (test.name in names(all.separated)) {
  PlotSpectraAsSigsWithUncertainty(
    all.separated[[test.name]]$inferred.target.spectra,
    title = test.name)
}

```

```{r, sig.and.uncertainty.denisty, fig.height=3, fig.width=7}
par(mfrow = c(1, 1))
par(mar = c(7, 5, 7, 2))
par(cex = 0.8)
par(cex.main = 1.4) 
for (test.name in names(all.separated)) {
  d.spect <- ICAMS::TransformCatalog(
    all.separated[[test.name]]$inferred.target.spectra,
    target.catalog.type = "density")
  PlotSpectraAsSigsWithUncertainty(
    d.spect,
    title = test.name)
}

```


### Stacked bar charts

```{r, stacked.charts}
par(mfrow = c(1, 1))
par(mar = c(7, 5, 7, 2))
par(cex = 0.8)
par(cex.main = 1.4)
for (test.name in names(all.separated)) {
  
  info <- all.separated[[test.name]]
  bg.spectra <- info$inferred.bg.spect #############
  ta.spectra <- info$inferred.target.spectra
  
  for (colnum in 1:ncol(bg.spectra)) {
    Plot1StackedSpectrum(
      bg.cat.1 = bg.spectra[ , colnum, drop = FALSE],
      target.cat.1 = ta.spectra[ , colnum, drop = FALSE])
  }
}

```


### Similarities between inferred signatures


```{r, gather.spectra.and.sigs}


all.target.spectra <- matrix(nrow = 96, ncol = 0)
for (test.name in names(all.separated)) {
  tmp <- all.separated[[test.name]]$inferred.target.spectra
  attr(tmp, "class") <- c("matrix", "array")
  all.target.spectra <- cbind(all.target.spectra, tmp)
}
colnames(all.target.spectra) <-
  sub(".vcf.inf.tg.spect", "",
      x = colnames(all.target.spectra),
      fixed = TRUE)

colnames(all.target.spectra) <-
  sub(".inf.tg.spect", "",
      x = colnames(all.target.spectra),
      fixed = TRUE)

colnames(all.target.spectra) <-
  sub("_SNVresult_intersect", "",
      x = colnames(all.target.spectra),
      fixed = TRUE)




```

```{r, cosine.sim, fig.height=8.5 fig.width=6.5}}

cosine.sim <- philentropy::distance(t(all.target.spectra), method = "cosine")
rownames(cosine.sim) <- colnames(all.target.spectra)
colnames(cosine.sim) <- colnames(all.target.spectra)
gplots::heatmap.2(x = cosine.sim,
                  dendrogram = "column",
                  margins = c(9, 9),
                  cex.axis = 0.5,
                  symm = TRUE,
                  trace = "none")

```

```{r, skip.last.oxaliplatin}
to.delete <- grep("Oxpl_cl4", colnames(all.target.spectra))
cosine.sim <- 
  philentropy::distance(t(all.target.spectra[ , -to.delete]), 
                        method = "cosine")
rownames(cosine.sim) <- colnames(all.target.spectra)[-to.delete]
colnames(cosine.sim) <- colnames(all.target.spectra)[-to.delete]
gplots::heatmap.2(x = cosine.sim,
                  dendrogram = "column",
                  margins = c(9, 9),
                  cex.axis = 0.5,
                  symm = TRUE,
                  trace = "none")
```


```{r, cossim, eval=FALSE, echo=FALSE}
cossim <- function(v1, v2) {
  if (!is.null(ncol(v1)))  {
    stopifnot(ncol(v1) == 1)
    v1 <- v1[ , 1]
  }
  if (!is.null(ncol(v2)))  {
    stopifnot(ncol(v2) == 1)
    v2 <- v2[ , 1]
  }
  lsa::cosine(v1, v2)
  
}
```


`r ifelse(params$showrecon, "### Reconstruct spectra", "")`

```{r, get.reconstructed.spectra, eval=FALSE, echo=params$showrecon}

### Comparisions of inferred spectra and inferred signatures"
reconstructed.target.spectra <- 
  round(inferred.sig %*% matrix(ret$exposures.to.target.sig, nrow = 1))
reconstructed.target.spectra <- 
  ICAMS::as.catalog(
    reconstructed.target.spectra,
    catalog.type   = "counts",
    region         = "genome",
    abundance      = attr(spectra, "abundance"),
    infer.rownames = TRUE)
colnames(reconstructed.target.spectra) <-
  paste0(colnames(spectra), "-mult-recon-spect")
pcat(reconstructed.target.spectra)


total.spectra <- reconstructed.target.spectra + inferred.bg.spectra


lapply(1:ncol(spectra), 
        function(col.index) {
          return(list(
            cossim = cossim(total.spectra[ , col.index], spectra[ , col.index]),
            e.dist = dist(rbind(total.spectra[ , col.index], spectra[ , col.index]), method = "euclidean")))})

```

`r ifelse(params$showrecon, "### Original and reconstructed spectra side-by-side", "")`

```{r, plot.orig.and.recon, eval=FALSE, echo=params$showrecon}
InterleaveMatrices <- function(m1, m2) {
  stopifnot(dim(m1) == dim(m2))
  i2 <- 1:ncol(m1) * 2
  i1 <- 1 + (0:(ncol(m1) - 1) * 2)
  out <- matrix(nrow = nrow(m1), ncol = 2 * ncol(m1))
  out[ , i1] <- m1
  out[ , i2] <- m2
  c.names <- character(2 * ncol(m1))
  c.names[i1] <- colnames(m1)
  c.names[i2] <- colnames(m2)
  colnames(out) <- c.names
  rownames(out) <- rownames(m1)
  return(out)
  
}

s.by.s <- InterleaveMatrices(spectra, total.spectra)
s.by.s <- ICAMS::as.catalog(s.by.s, 
                            region = "genome",
                            catalog.type = "counts",
                            abundance = attr(spectra, "abundance"))
```

```{r, plot.replicate1, eval=FALSE, echo=params$showrecon}
for (i in 0:(ncol(spectra) - 1)) {
  pcat(s.by.s[ , (2 * i + 1):(2 * i + 2) ])
}
```



```{r, sanity_check_1_is_target_needed, eval = FALSE}
## Sanity check: are both the background and the inferred signature needed?

### Is the inferred signature needed?

library(mSigAct)
m.opts <- mSigAct::DefaultManyOpts()
two.sigs2 <- two.sigs
two.sigs2[ , 1] <- two.sigs2[ , 1] / sum(two.sigs2[ , 1])
mSigAct::SignaturePresenceTest(
  spectra          = spectra,
  sigs             = two.sigs2,
  target.sig.index = 1,
  eval_f           = mSigAct::ObjFnBinomMaxLHNoRoundOK,
  m.opts           = m.opts)

```



```{r, sanity_check_2_is_backgrouind_needed, eval = FALSE}
### Is the background signature needed?

mSigAct::SignaturePresenceTest(
  spectra          = spectra,
  sigs             = two.sigs2,
  target.sig.index = 2,
  eval_f           = mSigAct::ObjFnBinomMaxLHNoRoundOK,
  m.opts           = m.opts)
```