---
title: "Platinum_Exploration_XY"
author: "Xinyi"
date: '2022-12-31'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Preparation

### prepare packages 
```{r, libraries, echo=TRUE, message=FALSE}
# CRAN packages
library(ICAMS)
require(philentropy)
require(factoextra)
require(gplots)
require(nloptr)

# Bioconductor
library(BSgenome.Hsapiens.1000genomes.hs37d5)
# If not available,
# install.packages("BiocManager")
# BiocManager::install("BSgenome.Hsapiens.1000genomes.hs37d5")

# Other
library(mSigBG)
# if not available
# install.packages("remotes")
# remotes::install_github("steverozen/mSigBG", ref = "1.0-branch")
library(PCAWG7)
# if not available
# remotes::install_github("steverozen/PCAWG7")
```

### Read Input data 
```{r}
setwd("/home/e0261891/project_folder/mSigBG/data-raw")
load("spectra/HepG2_and_MCF10A_Cis.spectra.Rdata")
```

### Catalog Plotting Functions
```{r, define_pcat1, echo=params$verbose}
# Plot a single catalog
pcat1 <- function(catalog, ylim = NULL) {
  par(pin = c(5, 1))
  par(mar = c(5, 4, 5, 4))
  par(cex = 0.8)
  par(cex.main = 1.4)
  bp <- ICAMS::PlotCatalog(catalog[ , 1, drop = FALSE],
                           upper   = TRUE,
                           xlabels = TRUE,
                           ylim    = ylim
                           )
  return(invisible(bp$plot.object))
}
```

```{r, define_pcat, echo=params$verbose}
pcat <- function(catalog) {
  par(pin = c(3*ncol(catalog), 1))
  par(mfrow = c(ncol(catalog), 1))
  par(mar = c(2, 4, 4, 2))
  par(cex = 0.8)
  par(cex.main = 1.4) 
  xlabels <- FALSE
  for (i in 1:ncol(catalog)) {
    if (FALSE && i == ncol(catalog)) { # FALSE an experiment
      xlabels <- TRUE
      par(mar = c(4.5, 4, 3, 2))
    }
    
    ICAMS::PlotCatalog(catalog[ , i, drop = FALSE],
                       upper = (i == 1),
                       xlabels = xlabels)
  }
}
```


### Read catalog

```{r, read.catalogs}
hepg2.car  <- ICAMS::ReadCatalog("spectra/HepG2_Car.csv", 
                                 ref.genome = BSgenome.Hsapiens.1000genomes.hs37d5,
                                 region = "genome",
                                 catalog.type = "counts")

hepg2.oxa  <- ICAMS::ReadCatalog("spectra/HepG2_Oxa.csv", 
                                 ref.genome = BSgenome.Hsapiens.1000genomes.hs37d5,
                                 region = "genome",
                                 catalog.type = "counts")

mcf10a.car <- ICAMS::ReadCatalog("spectra/MCF10A_Car.csv", 
                                 ref.genome = BSgenome.Hsapiens.1000genomes.hs37d5,
                                 region = "genome",
                                 catalog.type = "counts")

```

## Background Separation

### Background signatures, for refrence

```{r, plot.background, fig.height=3, fig.width=7} 

pcat(mSigBG::background.info[["MCF10A"]]$background.sig)
pcat(mSigBG::background.info[["HepG2"]]$background.sig)

```


## Separate the background and target signatures

```{r, separate.hepg2}
one.separation <- function(sig.name, sig.list, bg.sig.info, my.seed = 101010) {
  
  set.seed(my.seed, kind = "L'Ecuyer-CMRG")
  
  spectra <- sig.list[[sig.name]]
  
  if (is.null(attr(spectra, "abundance"))) {
    stop("NULL abundance for ", sig.name)
  }
  
  ret <- SeparateSignatureAndSpectra(
    spectra          = spectra,
    bg.sig.info      = bg.sig.info,
    m.opts           = NULL,
    start.b.fraction = 0.5,
    sig.name         = sig.name
  )

  return(ret)
}
```

# ####################### #
# Sample Based Separation #
# ####################### #

```{r, separate.hepg2}
one.sample.separation <- function(sig.name, sig.list, bg.sig.info, my.seed = 101010) {
  
  set.seed(my.seed, kind = "L'Ecuyer-CMRG")
  
  spectra <- sig.list[,sig.name,drop=FALSE]
  
  if (is.null(attr(spectra, "abundance"))) {
    stop("NULL abundance for ", sig.name)
  }
  
  ret <- SeparateSignatureAndSpectra(
    spectra          = spectra,
    bg.sig.info      = bg.sig.info,
    m.opts           = NULL,
    start.b.fraction = 0.5,
    sig.name         = sig.name
  )

  return(ret)
}
```


```{r, hepg2-cis&car}
hepg2.cis.separated <- lapply (X           = colnames(hepg2.exposures$HepG2.cis.sig),
                            FUN         = one.sample.separation,
                            sig.list    = hepg2.exposures$HepG2.cis.sig,
                            bg.sig.info = background.info[["HepG2"]])
names(hepg2.cis.separated) <- colnames(hepg2.exposures$HepG2.cis.sig)

hepg2.car.separated <- lapply (X           = colnames(hepg2.exposures$HepG2.car.sig),
                            FUN         = one.sample.separation,
                            sig.list    = hepg2.exposures$HepG2.car.sig,
                            bg.sig.info = background.info[["HepG2"]])
names(hepg2.car.separated) <- colnames(hepg2.exposures$HepG2.car.sig)
```

```{r, mcf10a-cis&car}
mcf10a.cis.separated <- lapply (X       = colnames(mcf10a.exposures$MCF10A.cis.sig),
                            FUN         = one.sample.separation,
                            sig.list    = mcf10a.exposures$MCF10A.cis.sig,
                            bg.sig.info = background.info[["MCF10A"]])
# Sum of elements in inferred signature is not 1; Mean relative difference: 1.4e-05

names(mcf10a.cis.separated) <- colnames(mcf10a.exposures$MCF10A.cis.sig)

mcf10a.car.separated <- lapply (X       = colnames(mcf10a.exposures$MCF10.car.sig),
                            FUN         = one.sample.separation,
                            sig.list    = mcf10a.exposures$MCF10.car.sig,
                            bg.sig.info = background.info[["MCF10A"]])

names(mcf10a.car.separated) <- colnames(mcf10a.exposures$MCF10.car.sig)

```
## Sanity check
```{r background.exposures}
background.info[["HepG2"]]$count.nbinom.mu
background.info[["MCF10A"]]$count.nbinom.mu
hepg2.cis.count <- lapply(hepg2.cis.separated, 
       function(x) { 
         exposures <- x$exposures.to.bg.sig
         names <- colnames(x$inferred.bg.spectra)
         names(exposures) <- sub("-inf.bg.spect", "", names, fixed = TRUE) # remove suffix in colname
         return(exposures)
       })
hepg2.car.count <- lapply(hepg2.car.separated, 
       function(x) { 
         exposures <- x$exposures.to.bg.sig
         names <- colnames(x$inferred.bg.spectra)
         names(exposures) <- sub("-inf.bg.spect", "", names, fixed = TRUE) # remove suffix in colname
         return(exposures)
       })
# bg count a bit strange
mcf10a.cis.count <- lapply(mcf10a.cis.separated, 
       function(x) { 
         exposures <- x$exposures.to.bg.sig
         names <- colnames(x$inferred.bg.spectra)
         names(exposures) <- sub("-inf.bg.spect", "", names, fixed = TRUE) # remove suffix in colname
         return(exposures)
       })
mcf10a.car.count <- lapply(mcf10a.car.separated, 
       function(x) { 
         exposures <- x$exposures.to.bg.sig
         names <- colnames(x$inferred.bg.spectra)
         names(exposures) <- sub("-inf.bg.spect", "", names, fixed = TRUE) # remove suffix in colname
         return(exposures)
       })
unlist(hepg2.cis.count)
unlist(hepg2.car.count)
unlist(mcf10a.cis.count)
unlist(mcf10a.car.count)

```


## Plot inferred sig, visualize the reconstruction 
```{r, fig.height=4, fig.width=7}
hepg2.cis.inferred.spectra <- hepg2.cis.separated[[1]]$inferred.target.sig.as.catalog
for (i in 2:length(hepg2.cis.separated)){
  hepg2.cis.inferred.spectra <- cbind(hepg2.cis.inferred.spectra, hepg2.cis.separated[[i]]$inferred.target.sig.as.catalog)
}
pcat(hepg2.cis.inferred.spectra)
```

```{r, fig.height=6, fig.width=7}
mcf10a.cis.inferred.spectra <- mcf10a.cis.separated[[1]]$inferred.target.sig.as.catalog
for (i in 2:length( mcf10a.cis.separated)){
   mcf10a.cis.inferred.spectra <- cbind( mcf10a.cis.inferred.spectra,  mcf10a.cis.separated[[i]]$inferred.target.sig.as.catalog)
}
pcat(mcf10a.cis.inferred.spectra)
```

```{r, fig.height=3, fig.width=7}
hepg2.car.inferred.spectra <- hepg2.car.separated[[1]]$inferred.target.sig.as.catalog
for (i in 1:length(hepg2.car.separated)){
  hepg2.car.inferred.spectra <- cbind(hepg2.car.inferred.spectra, hepg2.car.separated[[i]]$inferred.target.sig.as.catalog)
}
hepg2.car.inferred.spectra <- hepg2.car.inferred.spectra[,-1]
pcat(hepg2.car.inferred.spectra)
```

```{r, fig.height=5, fig.width=7}
mcf10a.car.inferred.spectra <- mcf10a.car.separated[[1]]$inferred.target.sig.as.catalog
for (i in 1:length(mcf10a.car.separated)){
  mcf10a.car.inferred.spectra <- cbind(mcf10a.car.inferred.spectra, mcf10a.car.separated[[i]]$inferred.target.sig.as.catalog)
}
mcf10a.car.inferred.spectra <- mcf10a.car.inferred.spectra[,-1]
pcat(mcf10a.car.inferred.spectra)
```

```{r}
all.sample.separated <- c(hepg2.cis.separated, hepg2.car.separated, mcf10a.cis.separated , mcf10a.car.separated)
```

```{r, sig.and.uncertainty.counts, fig.height=3, fig.width=7}
par(mfrow = c(1, 1))
par(mar = c(7, 5, 7, 2))
par(cex = 0.8)
par(cex.main = 1.4) 
for (test.name in names(all.sample.separated)) {
  PlotSpectraAsSigsWithUncertainty(
    all.sample.separated[[test.name]]$inferred.target.spectra,
    title = test.name)
}

```

```{r, sig.and.uncertainty.denisty, fig.height=3, fig.width=7}
par(mfrow = c(1, 1))
par(mar = c(7, 5, 7, 2))
par(cex = 0.8)
par(cex.main = 1.4) 
for (test.name in names(all.sample.separated)) {
  d.spect <- ICAMS::TransformCatalog(
    all.sample.separated[[test.name]]$inferred.target.spectra,
    target.catalog.type = "density")
  PlotSpectraAsSigsWithUncertainty(
    d.spect,
    title = test.name)
}

```
```{r, stacked.charts, fig.height=3, fig.width=7}
par(mfrow = c(1, 1))
par(mar = c(7, 5, 7, 2))
par(cex = 0.8)
par(cex.main = 1.4)
for (test.name in names(all.sample.separated)) {
  
  info <- all.sample.separated[[test.name]]
  bg.spectra <- info$inferred.bg.spectra
  ta.spectra <- info$inferred.target.spectra
  
  for (colnum in 1:ncol(bg.spectra)) {
    Plot1StackedSpectrum(
      background.spectrum = bg.spectra[ , colnum, drop = FALSE],
      target.spectrum     = ta.spectra[ , colnum, drop = FALSE])
  }
}

```

```{r}

```

# END of Sample based Separation

# #################################### #
# Two Ways of getting Inferred spectra #
# #################################### #

## Perform BG sep for all samples
### function for BG sep
```{r}
one.separation <- function(sig.name, sig.list, bg.sig.info, my.seed = 101010) {
  
  set.seed(my.seed, kind = "L'Ecuyer-CMRG")
  
  spectra <- sig.list[[sig.name]]
  
  if (is.null(attr(spectra, "abundance"))) {
    stop("NULL abundance for ", sig.name)
  }
  
  ret <- SeparateSignatureAndSpectra(
    spectra          = spectra,
    bg.sig.info      = bg.sig.info,
    m.opts           = NULL,
    start.b.fraction = 0.5,
    sig.name         = sig.name
  )

  return(ret)
}
```

### calling BG sep for both cell lines
```{r}
if (!file.exists("all.separated.Rdata")) {
  hepg2.separated <- lapply(X           = names(hepg2.exposures),
                            FUN         = one.separation,
                            sig.list    = hepg2.exposures,
                            bg.sig.info = background.info[["HepG2"]])
  names(hepg2.separated) <- names(hepg2.exposures)
}
if (!file.exists("all.separated.Rdata")) {
  mcf10a.separated <- lapply(X           = names(mcf10a.exposures),
                             FUN         = one.separation,
                             sig.list    = mcf10a.exposures,
                             bg.sig.info = background.info[["MCF10A"]])
  names(mcf10a.separated) <- names(mcf10a.exposures)
  
  all.separated <- c(hepg2.separated, mcf10a.separated)
  save(all.separated, file = "all.separated.Rdata")
} else {
  load("all.separated.Rdata")
}
```

## Method 1: obs.spectra - (bg.exposure * the background signature) 

```{r}
# Spectra of each sample (matrix)
all.spectra <- do.call(cbind, c(hepg2.exposures, mcf10a.exposures))

# Spectra of each sample (list)
all.obs.spectra <- c(hepg2.exposures, mcf10a.exposures)

# No. of mutation due to bg in each sample
all.bg.exposure <- lapply(all.separated, 
       function(x) { 
         bg.exposures <- x$exposures.to.bg.sig
         names <- colnames(x$inferred.bg.spectra)
         names(bg.exposures) <- sub("-inf.bg.spect", "", names, fixed = TRUE)
         return(bg.exposures)
       })

#unlist(c(all.bg.exposure))

all.bg.spectra <-lapply(all.separated, 
       function(x) { 
         bg.sig <- x$inferred.bg.spectra
         names <- colnames(x$inferred.bg.spectra)
         colnames(bg.sig) <- sub("-inf.bg.spect", "", names, fixed = TRUE)
         return(bg.sig)
       })


all.bg.sig <- lapply(all.bg.sig,function(x){
                  for (i in 1:ncol(x)){
                      temp <- (x[,i]/colSums(x)[i])
                      x[,i] <- temp
                  } 
                  return(x)
              })

rm("bg.spectra")
for (x in names(all.bg.exposure)){
  for (i in names(all.bg.exposure[[x]])){
    # this multiplication is problematic: all.bg.sig$x[,i] is a count signature 
    this.bg.spectra <- all.bg.exposure[[x]][i] * all.bg.sig[[x]][,i, drop=FALSE]
    if (!exists("bg.spectra")){
       bg.spectra <- this.bg.spectra
    }
    else{
      bg.spectra <- cbind(bg.spectra, this.bg.spectra)
    }
  }
}  

all.inferred.target.spectra.method1 <- all.spectra - bg.spectra

# transform the inferred spectra into catalog 
# plot the catalog 
# later on calculate cosine similarity with the other method


```


## Method 2: (obs.counts - bg.exposure) * sig.to.return 
```{r}
# Spectra of each sample (matrix)
all.spectra <- do.call(cbind, c(hepg2.exposures, mcf10a.exposures))
# No.of total mutation observed in each sample
all.obs.counts <- as.matrix(colSums(all.spectra))

# Spectra of each sample (list)
all.obs.spectra <- c(hepg2.exposures, mcf10a.exposures)
# No.of total mutation observed in each sample
all.obs.counts <- lapply(all.obs.spectra, colSums)


# No. of mutation due to bg in each sample
all.bg.exposure <- lapply(all.separated, 
       function(x) { 
         bg.exposures <- x$exposures.to.bg.sig
         names <- colnames(x$inferred.bg.spectra)
         names(bg.exposures) <- sub("-inf.bg.spect", "", names, fixed = TRUE)
         return(bg.exposures)
       })



# front part of the multiplication
# all.obs.counts - unlist(all.bg.exposure)

all.target.sig <-lapply(all.separated, 
       function(x) { 
         target.sig <- x$inferred.target.sig.as.catalog
         return(target.sig)
       })
names(all.target.sig)<-names(all.separated)

rm("inferred.target.spectra.method2")
for (i in names(all.separated)){
  for (j in 1:length(all.bg.exposure[[i]])){
    inferred.target.count <- all.obs.counts[[i]][j] - all.bg.exposure[[i]][j]
    temp.inferred.spectra <- inferred.target.count %*% all.target.sig[[i]][,1]
    #Error in all.target.sig[[i]][, j] : subscript out of bounds
    temp.inferred.spectra <- t(temp.inferred.spectra)
    colnames(temp.inferred.spectra) <- names(inferred.target.count)
    
    if(!exists("inferred.target.spectra.method2")){
      inferred.target.spectra.method2 <- temp.inferred.spectra
    }else{
      inferred.target.spectra.method2 <- cbind(inferred.target.spectra.method2,temp.inferred.spectra)
    }
  }
}

all.inferred.target.spectra.method2 <- inferred.target.spectra.method2
```

```{r}
hpg2.cis <- as.catalog(all.target.sig$HepG2.cis.sig, catalog.type="counts.signature",infer.rownames = TRUE)
pcat(cbind(all.target.sig$HepG2.cis.sig,all.target.sig$MCF10A.cis.sig))


mcf.cis <- as.catalog(all.target.sig$MCF10A.cis.sig, catalog.type="counts.signature",infer.rownames = TRUE)


```

```{r}
cossim(hpg2.cis, mcf.cis)
```


### Compare the two method

```{r, cossim}
cossim <- function(v1, v2) {
  if (!is.null(ncol(v1)))  {
    stopifnot(ncol(v1) == 1)
    v1 <- v1[ , 1]
  }
  if (!is.null(ncol(v2)))  {
    stopifnot(ncol(v2) == 1)
    v2 <- v2[ , 1]
  }
  lsa::cosine(v1, v2)
}
```


Cosine Similarity between the two method
```{r}
rm("all.cossim")
for (i in 1:ncol(all.inferred.target.spectra.method1)){
  this.cossim <- cossim(all.inferred.target.spectra.method1[,i,drop=FALSE], all.inferred.target.spectra.method2[,i,drop=FALSE])
  colnames(this.cossim) <- colnames(all.inferred.target.spectra.method1)[i]
  if(!exists("all.cossim")){
    all.cossim <- this.cossim
    }
  else {
    all.cossim <- cbind(all.cossim,this.cossim)
    }
}
as.matrix(t(all.cossim))
```


# ############################### #
# Cosine Similarity for Sub-parts #
# ############################### #

### Cosine similarity between the subcolors of each method


```{r}
# A function to obtain cosine similarity between all subcolor of two input spectra/signature
# the corresponding column of spectra 1 and spectra 2 are the vectors to compare

subcolor.cossim <- function(spectra1, spectra2){
  if(exists("all.subcolor.cossim"))  rm("all.subcolor.cossim", envir = sys.calls)
  
  
  subcolor.names <- c("C>A","C>G","C>T","T>A","T>C","T>G")
  for (i in 1:ncol(spectra1)){
    if (exists("this.subcolor.cossim")) rm("this.subcolor.cossim",envir = sys.calls)
    
    for (j in 1:6){
      start.index <- (j-1)*16+1
      this.cossim <- cossim(spectra1[start.index:(start.index+15),i,drop=FALSE], spectra2[start.index:(start.index+15),i,drop=FALSE])
      colnames(this.cossim) <- paste(colnames(spectra1)[i], "&", colnames(spectra2)[i])
      rownames(this.cossim) <- subcolor.names[j]
      if(!exists("this.subcolor.cossim")){
        this.subcolor.cossim <- this.cossim
      }
      else {
        this.subcolor.cossim <- rbind(this.subcolor.cossim,this.cossim)
      }
    }
    
    if(!exists("all.subcolor.cossim")){
      all.subcolor.cossim <- this.subcolor.cossim
    }
    else {
      all.subcolor.cossim <- cbind(all.subcolor.cossim,this.subcolor.cossim)
    }
  }
  return(all.subcolor.cossim)
}

```

```{r}

subcolor.cossim(all.inferred.target.spectra.method1[,"HepG2.cis.sig.HepG2_Cis_cl1",drop=FALSE], all.inferred.target.spectra.method1[,"MCF10A.cis.sig.MCF10A_Cis_cl1",drop=FALSE])

```

```{r}

spectra1 <- all.inferred.target.spectra.method1[,"HepG2.cis.sig.HepG2_Cis_cl1",drop=FALSE]
spectra2 <- all.inferred.target.spectra.method1[,"MCF10A.cis.sig.MCF10A_Cis_cl1",drop=FALSE]
if (exists("all.subcolor.cossim")) rm("all.subcolor.cossim")
  subcolor.names <- c("C>A","C>G","C>T","T>A","T>C","T>G")
  for (i in 1:ncol(spectra1)){
    if (exists("this.subcolor.cossim")) rm("this.subcolor.cossim")
    for (j in 1:6){
      start.index <- (j-1)*16+1
      this.cossim <- cossim(spectra1[start.index:(start.index+15),i,drop=FALSE], spectra2[start.index:(start.index+15),i,drop=FALSE])
      colnames(this.cossim) <- paste(colnames(spectra1)[i], "&", colnames(spectra2)[i])
      rownames(this.cossim) <- subcolor.names[j]
      if(!exists("this.subcolor.cossim")){
        this.subcolor.cossim <- this.cossim
      }
      else {
        this.subcolor.cossim <- rbind(this.subcolor.cossim,this.cossim)
      }
    }
    if(!exists("all.subcolor.cossim")){
      all.subcolor.cossim <- this.subcolor.cossim
    }
    else {
      all.subcolor.cossim <- cbind(all.subcolor.cossim,this.subcolor.cossim)
    }
  }

all.subcolor.cossim
```

### Cosine similarity between the subcolors of HepG2 and MCF10A

```{r}
# Cis-Sig
rm("this.subcolor.cossim")
for (j in 1:6){
    start.index <- (j-1)*16+1
    this.cossim <- cossim(all.inferred.target.spectra.method1[start.index:(start.index+15),"HepG2.cis.sig.HepG2_Cis_cl1", drop=FALSE], all.inferred.target.spectra.method1[start.index:(start.index+15), "MCF10A.cis.sig.MCF10A_Cis_cl1", drop=FALSE])
    colnames(this.cossim) <- " cis.sig.cl1"
    rownames(this.cossim) <- subcolor.names[j]
  if(!exists("this.subcolor.cossim")){
    this.subcolor.cossim <- this.cossim
    }
  else {
    this.subcolor.cossim <- rbind(this.subcolor.cossim,this.cossim)
    }
}
cl1 <- this.subcolor.cossim

rm("this.subcolor.cossim")
for (j in 1:6){
    start.index <- (j-1)*16+1
    this.cossim <- cossim(all.inferred.target.spectra.method1[start.index:(start.index+15),"HepG2.cis.sig.HepG2_Cis_cl2", drop=FALSE], all.inferred.target.spectra.method1[start.index:(start.index+15), "MCF10A.cis.sig.MCF10A_Cis_cl2", drop=FALSE])
    colnames(this.cossim) <- " cis.sig.cl2"
    rownames(this.cossim) <- subcolor.names[j]
  if(!exists("this.subcolor.cossim")){
    this.subcolor.cossim <- this.cossim
    }
  else {
    this.subcolor.cossim <- rbind(this.subcolor.cossim,this.cossim)
    }
}
cl2 <- this.subcolor.cossim


rm("this.subcolor.cossim")
for (j in 1:6){
    start.index <- (j-1)*16+1
    this.cossim <- cossim(all.inferred.target.spectra.method1[start.index:(start.index+15),"HepG2.cis.sig.HepG2_Cis_cl3", drop=FALSE], all.inferred.target.spectra.method1[start.index:(start.index+15), "MCF10A.cis.sig.MCF10A_Cis_cl3", drop=FALSE])
    colnames(this.cossim) <- " cis.sig.cl3"
    rownames(this.cossim) <- subcolor.names[j]
  if(!exists("this.subcolor.cossim")){
    this.subcolor.cossim <- this.cossim
    }
  else {
    this.subcolor.cossim <- rbind(this.subcolor.cossim,this.cossim)
    }
}
cl3 <- this.subcolor.cossim

cbind(cl1, cl2, cl3)
```

```{r}
# Car-Sig
rm("this.subcolor.cossim")
for (j in 1:6){
    start.index <- (j-1)*16+1
    this.cossim <- cossim(all.inferred.target.spectra.method1[start.index:(start.index+15),"HepG2.car.sig.HepG2_Car_cl1", drop=FALSE], all.inferred.target.spectra.method1[start.index:(start.index+15), "MCF10.car.sig.MCF10A_Car_cl1", drop=FALSE])
    colnames(this.cossim) <- " car.sig.cl1"
    rownames(this.cossim) <- subcolor.names[j]
  if(!exists("this.subcolor.cossim")){
    this.subcolor.cossim <- this.cossim
    }
  else {
    this.subcolor.cossim <- rbind(this.subcolor.cossim,this.cossim)
    }
}
cl1 <- this.subcolor.cossim

rm("this.subcolor.cossim")
for (j in 1:6){
    start.index <- (j-1)*16+1
    this.cossim <- cossim(all.inferred.target.spectra.method1[start.index:(start.index+15),"HepG2.car.sig.HepG2_Car_cl2", drop=FALSE], all.inferred.target.spectra.method1[start.index:(start.index+15), "MCF10.car.sig.MCF10A_Car_cl2", drop=FALSE])
    colnames(this.cossim) <- " car.sig.cl2"
    rownames(this.cossim) <- subcolor.names[j]
  if(!exists("this.subcolor.cossim")){
    this.subcolor.cossim <- this.cossim
    }
  else {
    this.subcolor.cossim <- rbind(this.subcolor.cossim,this.cossim)
    }
}
cl2 <- this.subcolor.cossim

rm("this.subcolor.cossim")
for (j in 1:6){
    start.index <- (j-1)*16+1
    this.cossim <- cossim(all.inferred.target.spectra.method1[start.index:(start.index+15),"HepG2.car.sig.HepG2_Car_cl3", drop=FALSE], all.inferred.target.spectra.method1[start.index:(start.index+15), "MCF10.car.sig.MCF10A_Car_cl3", drop=FALSE])
    colnames(this.cossim) <- " car.sig.cl3"
    rownames(this.cossim) <- subcolor.names[j]
  if(!exists("this.subcolor.cossim")){
    this.subcolor.cossim <- this.cossim
    }
  else {
    this.subcolor.cossim <- rbind(this.subcolor.cossim,this.cossim)
    }
}
cl3 <- this.subcolor.cossim

cbind(cl1, cl2, cl3)
```


```{r}
HepG2_cis_cl <- c("HepG2.cis.sig.HepG2_Cis_cl1", "HepG2.cis.sig.HepG2_Cis_cl2", "HepG2.cis.sig.HepG2_Cis_cl3", "HepG2.cis.sig.HepG2_Cis_cl4" )
MCF10A_cis_cl <- c("MCF10A.cis.sig.MCF10A_Cis_cl2", "MCF10A.cis.sig.MCF10A_Cis_cl3", "MCF10A.cis.sig.MCF10A_Cis_cl4", "MCF10A.cis.sig.MCF10A_Cis_cl5","MCF10A.cis.sig.MCF10A_Cis_cl6")
for (i in ){
  for(j in ){
    
  }
}
  
```


```{r}

```

# END of Cosine Similarity for Sub-parts

