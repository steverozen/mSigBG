---
title: "Platinum_Organized_2.0_XY"
author: "Xinyi"
date: "2023-02-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Preparation

### prepare packages 
```{r, libraries, echo=TRUE, message=FALSE}
# CRAN packages
library(ICAMS)
library(philentropy)
library(factoextra)
library(gplots)
library(nloptr)

# Bioconductor
# library(BSgenome.Hsapiens.1000genomes.hs37d5)
# If not available,
# install.packages("BiocManager")
# BiocManager::install("BSgenome.Hsapiens.1000genomes.hs37d5")

# Other
library(mSigBG)
# if not available
# install.packages("remotes")
# remotes::install_github("steverozen/mSigBG", ref = "1.0-branch")
library(PCAWG7)
# if not available
# remotes::install_github("steverozen/PCAWG7")
```

## Functions for later

### Catalog Plotting Functions
```{r}
#{r, define_pcat, echo=params$verbose}
pcat <- function(catalog) {
  par(pin = c(3*ncol(catalog), 1))
  par(mfrow = c(ncol(catalog), 1))
  par(mar = c(2, 4, 4, 2))
  par(cex = 0.8)
  par(cex.main = 1.4) 
  xlabels <- FALSE
  for (i in 1:ncol(catalog)) {
    if (FALSE && i == ncol(catalog)) { # FALSE an experiment
      xlabels <- TRUE
      par(mar = c(4.5, 4, 3, 2))
    }
    
    ICAMS::PlotCatalog(catalog[ , i, drop = FALSE],
                       upper = (i == 1),
                       xlabels = xlabels)
  }
}
```

### Background separation function: Separate the background and target signatures

```{r, separate.hepg2}
one.separation <- function(sig.name, spectra, bg.sig.info, my.seed = 101010) {
  
  set.seed(my.seed, kind = "L'Ecuyer-CMRG")
  
  if (is.null(attr(spectra, "abundance"))) {
    stop("NULL abundance for ", sig.name)
  }
  
  ret <- SeparateSignatureAndSpectra(
    spectra          = spectra,
    bg.sig.info      = bg.sig.info,
    m.opts           = NULL,
    start.b.fraction = 0.5,
    sig.name         = sig.name
  )

  return(ret)
}
```


## Read Input data 

The variables here contain ICAMS catalogs containing
spectra; each variable is for one
cell line and one exposure.

```{r, get_spectra}
# library(BSgenome.Hsapiens.1000genomes.hs37d5)

hepg2.car  <- ICAMS::ReadCatalog("spectra/HepG2_Car.csv", 
                                 #ref.genome = BSgenome.Hsapiens.1000genomes.hs37d5,
                                 region = "genome",
                                 catalog.type = "counts")

hepg2.oxa  <- ICAMS::ReadCatalog("spectra/HepG2_Oxa.csv", 
                                 #ref.genome = BSgenome.Hsapiens.1000genomes.hs37d5,
                                 region = "genome",
                                 catalog.type = "counts")

mcf10a.car <- ICAMS::ReadCatalog("spectra/MCF10A_Car.csv", 
                                 #ref.genome = BSgenome.Hsapiens.1000genomes.hs37d5,
                                 region = "genome",
                                 catalog.type = "counts")

hepg2.cis <- mSigBG::example.spectra$HepG2.cisplatin
colnames(hepg2.cis)<- sub(".vcf", "", colnames(hepg2.cis), fixed = TRUE)

mcf10a.cis <- mSigBG::example.spectra$MCF10A.cisplatin
colnames(mcf10a.cis)<- sub(".vcf", "", colnames(mcf10a.cis), fixed = TRUE)

#load("~/project_folder/mSigBG/data-raw/spectra/HepG2_and_MCF10A_Cis.spectra.Rdata") # same results as above

```


### Separate intrinsic from target for all cell line X exposure pairs

```{r}
# Are the inferred target signatures by method 1 similar across the 4 hepg2 spectra?

hepg2.cis.sep <- one.separation("hepg2.cis", hepg2.cis, background.info[["HepG2"]])



# Are the inferred target signatures by method 1 similar across the 4 mcfa1 spectra?

mcf10a.cis.sep <- one.separation("mcf10a.cis", mcf10a.cis, background.info[["HepG2"]])


# If the 2 quesions above are true, then look at overall cossim between 
# the inferred target signatures of hepg2 and mcf10a as a whole and by
# subcolor_sim.
```

# Exploration
## Two Ways of getting Inferred spectra 

### Method 1: obs.spectra - (bg.exposure * the background signature) 
Inferred spectra obtained from observed spectra minus background spectra 
```{r}
target_sig_M1 <- function(obs.spectra, spectra.sep) {
  bg.exposure <- spectra.sep$exposures.to.bg.sig
  bg.spectra <- spectra.sep$inferred.bg.spectra
  bg.sig <- spectra.sep$inferred.bg.spectra/colSums(bg.spectra)
  
  target.spectra <- obs.spectra[,1, drop=FALSE]  - bg.exposure[1] * bg.sig[, i, drop=FALSE]
  if(length(bg.exposure)>1){
    for (i in 2:length(bg.exposure)){
      target.spectra <- cbind(target.spectra, obs.spectra[,i, drop=FALSE]  - bg.exposure[i] * bg.sig[, i, drop=FALSE])
    }
  }
  #target.sig.method1 <- target.spectra/colSums(target.spectra)
  
  return(target.spectra)
  #return(target.sig.method1)
}
```


#### comparison across clones 
##### HepG2-Cisplatinum
```{r}
target.spectra <- target_sig_M1(hepg2.cis, hepg2.cis.sep)
target.sig.method1 <- target.spectra/colSums(target.spectra)
```

```{r}

```


```{r,fig.height=5, fig.width=7}
pcat(target.spectra)
```

```{r, fig.height=5, fig.width=5}
cosine.sim <- suppressMessages(
  philentropy::distance(t(target.sig.method1), method = "cosine"))
  
rownames(cosine.sim) <- colnames(target.sig.method1)
colnames(cosine.sim) <- colnames(target.sig.method1)
gplots::heatmap.2(x = cosine.sim,
                  dendrogram = "column",
                  margins = c(15, 15),
                  cex.axis = 0.9,
                  symm = TRUE,
                  trace = "none")
```

##### MCF10A-Cisplatinum
```{r}
target.spectra <- target_sig_M1(mcf10a.cis, mcf10a.cis.sep)
target.sig.method1 <- target.spectra/colSums(target.spectra)
```

```{r,fig.height=8, fig.width=7}
pcat(target.spectra)
```

```{r, fig.height=5, fig.width=5}
cosine.sim <- suppressMessages(
  philentropy::distance(t(target.sig.method1), method = "cosine"))
  
rownames(cosine.sim) <- colnames(target.sig.method1)
colnames(cosine.sim) <- colnames(target.sig.method1)
gplots::heatmap.2(x = cosine.sim,
                  dendrogram = "column",
                  margins = c(15, 15),
                  cex.axis = 0.9,
                  symm = TRUE,
                  trace = "none")
```

### Method 2: (obs.counts - bg.exposure) * sig.to.return 
Inferred spectra obtained from inferred target signature multiply # of target mutations (observed -bg) 
```{r}
# No. of mutation due to bg in each sample
target_sig_M2 <- function(obs.spectra, spectra.sep){
  bg.exposures <- spectra.sep$exposures.to.bg.sig
  names(bg.exposures) <- sub("-inf.bg.spect", "", colnames(spectra.sep$inferred.bg.spectra), fixed = TRUE)
  
  target.sig <-spectra.sep$inferred.target.sig.as.catalog
  
  inferred.target.count <- sum(obs.spectra[,1]) - bg.exposures[1]
  target.spec.method2 <- inferred.target.count * target.sig
  
  if(length(bg.exposure>1)){
    for (j in 2:length(bg.exposure)){
      inferred.target.count <- sum(obs.spectra[,j]) - bg.exposures[j]
      temp.inferred.spectra <- inferred.target.count * target.sig
      target.spec.method2 <- cbind(target.spec.method2,temp.inferred.spectra)
    }
  }
  return(target.spec.method2)
}

```

```{r}
hepg2.cis.target.spec.M2 <- target_sig_M2(hepg2.cis, hepg2.cis.sep)
```

```{r}
mcf10a.cis.target.spec.M2 <- target_sig_M2(mcf10a.cis, mcf10a.cis.sep)
```

```{r}
# when comparing the target spectra of the two cell line (each cell line has multiple clones), the cosine similarity dropped
# my guess: cosine similarity calculated this way took into account the variation in #mutation-by-target-sig across the different clones
philentropy::cosine_dist(hepg2.cis.target.spec.M2,mcf10a.cis.target.spec.M2, testNA = TRUE)
```

```{r}
# when comparing the target signature of the two cell line --> the similarity is higher
philentropy::cosine_dist(hepg2.cis.sep$inferred.target.sig.as.catalog, mcf10a.cis.sep$inferred.target.sig.as.catalog, testNA = TRUE)
```
```{r, fig.height=3, fig.width=7}
pcat(cbind(hepg2.cis.sep$inferred.target.sig.as.catalog,mcf10a.cis.sep$inferred.target.sig.as.catalog))
```
Background Signature of the two cell line
```{r, fig.height=3, fig.width=7}
pcat(cbind(mSigBG::background.info[["HepG2"]]$background.sig, mSigBG::background.info[["MCF10A"]]$background.sig))
```
```{r}
subcolor_sim(mSigBG::background.info[["HepG2"]]$background.sig,hepg2.cis.sep$inferred.target.sig.as.catalog)
```

```{r}
subcolor_sim(mSigBG::background.info[["MCF10A"]]$background.sig,mcf10a.cis.sep$inferred.target.sig.as.catalog)
```


